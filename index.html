<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="theme-color" content="#126CE3">
    <meta name="description" content="A fun shoe matching game">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TheGame">
    <link rel="apple-touch-icon" href="./img/icon-192.png">
    <link rel="manifest" href="manifest.webmanifest">
    <link rel="stylesheet" href="css/theGame.min.css">
    <title>Ergonote: The Game</title>
</head>
<body>
    <canvas id="cnv"></canvas>
    <button id="fs" style="position:fixed;right:12px;top:12px;z-index:10;font-family:'Press Start 2P';font-size:12px;padding:8px;border-radius:6px;border:1px solid #000;background:#fff;">Fullscreen</button>
    <script type="module">
      // Register service worker for PWA/install/offline
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', async () => {
          try {
            const registration = await navigator.serviceWorker.register('./sw.js', { scope: './' });
            console.log('ServiceWorker registration successful with scope:', registration.scope);
            
            // Add a custom install button if needed
            window.addEventListener('beforeinstallprompt', (e) => {
              // Prevent Chrome 67 and earlier from automatically showing the prompt
              e.preventDefault();
              // Stash the event so it can be triggered later
              const deferredPrompt = e;
              // Update UI to notify the user they can add to home screen
              console.log('App can be installed - showing install button');
              
              // Optional: Add a custom install button if you want
              /*
              const installBtn = document.createElement('button');
              installBtn.textContent = 'Install App';
              installBtn.style.position = 'fixed';
              installBtn.style.left = '12px';
              installBtn.style.top = '12px';
              installBtn.style.zIndex = '10';
              installBtn.style.fontFamily = "'Press Start 2P'";
              installBtn.style.fontSize = '12px';
              installBtn.style.padding = '8px';
              installBtn.style.borderRadius = '6px';
              installBtn.style.border = '1px solid #000';
              installBtn.style.background = '#fff';
              document.body.appendChild(installBtn);
              
              installBtn.addEventListener('click', async () => {
                // Show the install prompt
                deferredPrompt.prompt();
                // Wait for the user to respond to the prompt
                const { outcome } = await deferredPrompt.userChoice;
                console.log(`User ${outcome} the A2HS prompt`);
                // We've used the prompt, and can't use it again, so hide the button
                installBtn.style.display = 'none';
              });
              */
            });
          } catch (error) {
            console.error('ServiceWorker registration failed:', error);
          }
        });
      }

      // Fullscreen toggle with vendor prefixes and CSS fallback for iOS Safari
      const btn = document.getElementById('fs');
      const canvasEl = document.getElementById('cnv');
      const el = canvasEl || document.documentElement;
      let isIOSFullscreen = false; // Track iOS pseudo-fullscreen state

      // Detect iOS devices
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                    (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

      const isFullscreen = () => {
        if (isIOS) {
          return isIOSFullscreen || document.body.classList.contains('fs-mode');
        }
        return !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
      };

      // Function to recalculate canvas when entering/exiting fullscreen
      const recalculateCanvas = () => {
        // Give the browser time to adjust to fullscreen
        setTimeout(() => {
          // Trigger game UI recalculation
          if (window.theGameInstance && window.theGameInstance.game) {
            window.theGameInstance.game.init();
            // Force a redraw
            window.theGameInstance.render();
          }
        }, 100);
      };

      const enterFullscreen = async () => {
        try {
          if (isIOS) {
            // iOS Safari specific handling
            isIOSFullscreen = true;
            document.body.classList.add('fs-mode');
            // Hide Safari UI by scrolling
            window.scrollTo(0, 1);
            recalculateCanvas();
          } else if (el.requestFullscreen) {
            await el.requestFullscreen();
          } else if ((el).webkitRequestFullscreen) {
            (el).webkitRequestFullscreen();
          } else if ((el).msRequestFullscreen) {
            (el).msRequestFullscreen();
          } else {
            // CSS fallback for other browsers without Fullscreen API
            document.body.classList.add('fs-mode');
            recalculateCanvas();
          }
          
          // Best effort orientation lock (may be ignored)
          if (screen.orientation && screen.orientation.lock) {
            screen.orientation.lock('portrait').catch(() => {});
          }
        } catch (e) {
          console.error('Enter fullscreen error', e);
          document.body.classList.add('fs-mode');
          if (isIOS) isIOSFullscreen = true;
          recalculateCanvas();
        }
      };

      const exitFullscreen = async () => {
        try {
          if (isIOS) {
            isIOSFullscreen = false;
            document.body.classList.remove('fs-mode');
            recalculateCanvas();
          } else if (document.exitFullscreen) {
            await document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            await document.webkitExitFullscreen();
          } else if (document.msExitFullscreen) {
            await document.msExitFullscreen();
          } else {
            document.body.classList.remove('fs-mode');
            recalculateCanvas();
          }
        } catch (e) {
          // ignore
        } finally {
          document.body.classList.remove('fs-mode');
          if (isIOS) isIOSFullscreen = false;
          recalculateCanvas();
        }
      };

      btn?.addEventListener('click', () => {
        if (!isFullscreen()) {
          enterFullscreen();
        } else {
          exitFullscreen();
        }
      });

      // Keep CSS fallback state in sync with API changes and handle canvas recalculation
      ['fullscreenchange', 'webkitfullscreenchange', 'MSFullscreenChange'].forEach(ev => {
        document.addEventListener(ev, () => {
          if (!isFullscreen() && !isIOS) {
            document.body.classList.remove('fs-mode');
          }
          recalculateCanvas();
        });
      });

      // Handle window resize events (including orientation changes on mobile)
      window.addEventListener('resize', () => {
        recalculateCanvas();
      });

      // Handle orientation change on mobile devices
      window.addEventListener('orientationchange', () => {
        setTimeout(recalculateCanvas, 500); // Delay to allow orientation to complete
      });
    </script>
    <script type="module">
      import { theGame } from './js/theGame.js';
      // The game will initialize automatically when the script is loaded
    </script>
</body>
</html>